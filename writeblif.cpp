void Module::WriteBlifSimple(const string &name, ModuleType *modType) {

    //get map of all the library cells
    map<string, Librarycell *> cells;
    for (list<Block *>::iterator bi = blocks.begin(); bi != blocks.end(); ++bi)
        cells[(*bi)->cell->Name()] = (*bi)->cell;

    string filename = name + ".blif";
    ofstream out(filename.c_str());
    if (!out)
        throw ("Cannot open " + filename + " for writing");

    out << "# Netlist " << name << " generated by gnl " << Globals::version << " on " << time << endl;
    WriteInfoHeader(out, modType, "# ");
    

    out << ".model " << name << "\n";
    // write .inputs and .outputs
    CounterMap netMap;
    if (!inputs.empty()) {
        out << ".inputs";
        for (list<InputNet *>::iterator ni = inputs.begin(); ni != inputs.end(); ++ni)
            out << " n" << netMap[*ni] << " pclk";
        out << endl;
    }
    if (!outputs.empty()) {
        out << ".outputs";
        for (list<OutputNet *>::iterator ni = outputs.begin(); ni != outputs.end(); ++ni)
            out << " n" << netMap[*ni];
        out << endl;
    }
//  //write library cells
//    for (map<string, Librarycell *>::iterator li = cells.begin(); li != cells.end(); ++li) {
//        out << (li->second->Sequential() ? "sequential " : "combinational ") << li->first << endl;
//        out << ".names" << << endl
//        if (li->second->I()) {
//            out << "input";
//            for (int i = 1; i <= li->second->I(); ++i)
//                out << " i" << i;
//            out << endl;
//        }
//        if (li->second->O()) {
//            out << "output";
//            for (int i = 1; i <= li->second->O(); ++i)
//                out << " o" << i;
//            out << endl;
//        }
//        out << "area " << (argRead.areaAsWeight ? li->second->Weight() : li->second->Size()) << endl;
//        out << "end\n\n";
//    }
//    

    
    // Writing the blocks interconnects and functions
    for (list<Block*>::iterator bi = blocks.begin(); bi != blocks.end(); ++bi) {
    	string blockName = (*bi)->cell->Name();
    
    	if (blockName == "latch"){
    	out << ".latch ";
    	for (vector<Net *>::iterator ni = (*bi)->inputs.begin(); ni != (*bi)->inputs.end(); ++ni)
	    out << " n" << netMap[*ni];
	for (vector<OutputNet *>::iterator ni = (*bi)->outputs.begin(); ni != (*bi)->outputs.end(); ++ni)
	    out << " n" << netMap[*ni];
	out << "re pclk 2\n";
	}
	
	else if (blockName == "inv"){
	out << ".names ";
	for (vector<Net *>::iterator ni = (*bi)->inputs.begin(); ni != (*bi)->inputs.end(); ++ni)
	    out << " n" << netMap[*ni];
	for (vector<OutputNet *>::iterator ni = (*bi)->outputs.begin(); ni != (*bi)->outputs.end(); ++ni)
	    out << " n\n" << netMap[*ni];
	out << "0 1\n1 0\n";
	}

	else if (blockName == "and2"){

	out << ".names ";    	
	for (vector<Net *>::iterator ni = (*bi)->inputs.begin(); ni != (*bi)->inputs.end(); ++ni)
	    out << " n" << netMap[*ni];
	for (vector<OutputNet *>::iterator ni = (*bi)->outputs.begin(); ni != (*bi)->outputs.end(); ++ni)
	    out << " n\n" << netMap[*ni];
	out << "11 1\n";
	}
	else if (blockName == "nand3") {
	out << ".names ";
	for (vector<Net *>::iterator ni = (*bi)->inputs.begin(); ni != (*bi)->inputs.end(); ++ni)
	    out << " n" << netMap[*ni];
	for (vector<OutputNet *>::iterator ni = (*bi)->outputs.begin(); ni != (*bi)->outputs.end(); ++ni)
	    out << " n\n" << netMap[*ni];
	out << "111 0\n";
	}

	else if (blockName == "and3"){
	out << ".names ";
	for (vector<Net *>::iterator ni = (*bi)->inputs.begin(); ni != (*bi)->inputs.end(); ++ni)
	    out << " n" << netMap[*ni];
	for (vector<OutputNet *>::iterator ni = (*bi)->outputs.begin(); ni != (*bi)->outputs.end(); ++ni)
	    out << " n\n" << netMap[*ni];
	out << "111 1\n";
	}

	else if (blockName == "xor2"){
	out << ".names ";
	for (vector<Net *>::iterator ni = (*bi)->inputs.begin(); ni != (*bi)->inputs.end(); ++ni)
	    out << " n" << netMap[*ni];
	for (vector<OutputNet *>::iterator ni = (*bi)->outputs.begin(); ni != (*bi)->outputs.end(); ++ni)
	    out << " n\n" << netMap[*ni];
	out << "01 1\n10 1\n";
	}
    }
    
 

//    for (list<Block *>::iterator bi = blocks.begin(); bi != blocks.end(); ++bi) {
//        out << (*bi)->cell->Name();
//        for (vector<Net *>::iterator ni = (*bi)->inputs.begin(); ni != (*bi)->inputs.end(); ++ni)
//            out << " n" << netMap[*ni];
//        for (vector<OutputNet *>::iterator ni = (*bi)->outputs.begin(); ni != (*bi)->outputs.end(); ++ni)
//            out << " n" << netMap[*ni];
//        out << endl;
//    }
    out << "end\n";
}

